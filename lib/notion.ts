import { Client } from '@notionhq/client';
import { 
  getCategoryNames, 
  getCategoryIcon as getIconFromConfig,
  isValidCategory,
  getAllCategories
} from './categoryConfig';

// Initialize Notion client
const notionApiKey = process.env.NOTION_API_KEY;
const notionDatabaseId = process.env.NOTION_DATABASE_ID;

if (!notionApiKey) {
  throw new Error('NOTION_API_KEY is not defined in environment variables');
}

if (!notionDatabaseId) {
  throw new Error('NOTION_DATABASE_ID is not defined in environment variables');
}

export const notion = new Client({
  auth: notionApiKey,
});

/**
 * Get allowed categories from config file
 * Categories are now loaded from config/categories.json
 * See docs/CUSTOMIZE_CATEGORIES.md for customization instructions
 */
export function getAllowedCategories(): string[] {
  return getCategoryNames();
}

/**
 * Category type - dynamically based on config
 * Note: For type safety in tests, we use string instead of const assertion
 */
export type Category = string;

/**
 * Gets the emoji icon for a category
 * Now loaded from config file
 */
export function getCategoryIcon(category: Category): string {
  return getIconFromConfig(category);
}

/**
 * Validates that a category is one of the allowed categories
 * Falls back to 'Personal' if category is invalid
 * 
 * NOTE: Gemini should return exact category names, but this provides
 * a safety fallback in case of unexpected responses.
 */
export function validateCategory(category: string): Category {
  // Check if it's a valid category (exact match, case-sensitive)
  if (isValidCategory(category)) {
    return category;
  }
  
  // Fallback to Personal for invalid categories
  console.warn(`Invalid category "${category}", falling back to: Personal`);
  return 'Personal';
}

/**
 * Truncates text to a maximum length, preserving word boundaries
 * Handles Burmese text (Unicode) properly
 */
export function truncateSummary(text: string, maxLength: number = 200): string {
  if (!text) {
    return '';
  }
  
  // If already short enough, return as-is
  if (text.length <= maxLength) {
    return text;
  }
  
  // Truncate to maxLength
  let truncated = text.substring(0, maxLength);
  
  // Find last space to avoid cutting mid-word
  const lastSpace = truncated.lastIndexOf(' ');
  
  // Only use space boundary if it's in the last 20% of the text
  // This prevents truncating too short
  if (lastSpace > maxLength * 0.8) {
    truncated = truncated.substring(0, lastSpace);
  }
  
  return truncated.trim() + '...';
}

/**
 * Validates that the Notion database exists and is accessible
 */
export async function validateDatabase(): Promise<boolean> {
  try {
    await notion.databases.retrieve({
      database_id: notionDatabaseId!,
    });
    return true;
  } catch (error) {
    console.error('Failed to validate Notion database:', error);
    return false;
  }
}

/**
 * Data structure for creating a voice note page
 */
export interface VoiceNoteData {
  title: string;
  summary: string;
  content: string;
  category: string;
  tags: string[];
}

/**
 * Result structure returned after creating a page
 */
export interface CreatePageResult {
  success: boolean;
  pageId?: string;
  pageUrl?: string;
  error?: string;
  categoryMapped?: string;
}

/**
 * Creates a voice note page in Notion with properties and body content
 * 
 * @param data - Voice note data (generated by Gemini AI in real usage)
 * @returns Result with page ID, URL, and status
 */
export async function createVoiceNotePage(
  data: VoiceNoteData
): Promise<CreatePageResult> {
  try {
    // Validate category (should be exact match from Gemini)
    const validatedCategory = validateCategory(data.category);
    
    // Get category icon
    const categoryIcon = getCategoryIcon(validatedCategory);
    
    // Truncate summary to 200 characters
    const truncatedSummary = truncateSummary(data.summary, 200);
    
    // Create the page with properties and content
    const response = await notion.pages.create({
      parent: {
        database_id: notionDatabaseId!,
      },
      // Set page icon based on category
      icon: {
        type: 'emoji',
        emoji: categoryIcon,
      },
      properties: {
        // Title property - try common names
        Name: {
          title: [
            {
              text: {
                content: data.title,
              },
            },
          ],
        },
        // Summary property (text)
        Summary: {
          rich_text: [
            {
              text: {
                content: truncatedSummary,
              },
            },
          ],
        },
        // Category property (select)
        Category: {
          select: {
            name: validatedCategory,
          },
        },
        // Tags property (multi-select)
        Tags: {
          multi_select: data.tags.map((tag) => ({
            name: tag,
          })),
        },
      },
      // Page body content (full transcription)
      children: [
        {
          object: 'block',
          type: 'paragraph',
          paragraph: {
            rich_text: [
              {
                type: 'text',
                text: {
                  content: data.content,
                },
              },
            ],
          },
        },
      ],
    });

    // Extract page URL and ID from response
    const pageId = response.id;
    // Notion pages follow this URL pattern
    const pageUrl = `https://notion.so/${pageId.replace(/-/g, '')}`;

    return {
      success: true,
      pageId,
      pageUrl,
      categoryMapped: validatedCategory,
    };
  } catch (error) {
    console.error('Failed to create Notion page:', error);
    
    let errorMessage = 'Unknown error occurred';
    if (error instanceof Error) {
      errorMessage = error.message;
    }
    
    return {
      success: false,
      error: errorMessage,
    };
  }
}
